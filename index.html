<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>我的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="https://coderonepolo.github.io/index.html">
<meta property="og:site_name" content="我的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我的博客">
  
    <link rel="alternative" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			        <img src="http://upload.jianshu.io/users/upload_avatars/1940317/467c3cdadd72.JPG" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">菠了个菜</a></h1>
		</hgroup>

		
		<p class="header-subtitle">君子如航，夏日弥光</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/">iOS</a></li>
	        
				<li><a href="/">Python</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/CoderOnePolo" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://www.weibo.com/1835873711" title="weibo">weibo</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">菠了个菜</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://upload.jianshu.io/users/upload_avatars/1940317/467c3cdadd72.JPG" class="js-avatar show">
				
			</div>
			<hgroup>
			  <h1 class="header-author">菠了个菜</h1>
			</hgroup>
			
			<p class="header-subtitle">君子如航，夏日弥光</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/">iOS</a></li>
		        
					<li><a href="/">Python</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/CoderOnePolo" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://www.weibo.com/1835873711" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-Jenkins-fastlane-KIF自动化测试总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/14/Jenkins-fastlane-KIF自动化测试总结/">Jenkins+fastlane+KIF自动化测试总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Jenkins-fastlane-KIF自动化测试总结"><a href="#Jenkins-fastlane-KIF自动化测试总结" class="headerlink" title="Jenkins+fastlane+KIF自动化测试总结"></a>Jenkins+fastlane+KIF自动化测试总结</h1><p>####简要：在Jenkins环境下使用脚本执行fastlane命令，可以实现代码每次push到远程仓库时，服务器后台自动构建测试并生成图表类测试报告</p>
<h3 id="1-安装fastlane"><a href="#1-安装fastlane" class="headerlink" title="1. 安装fastlane"></a>1. 安装fastlane</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install fastlane</div></pre></td></tr></table></figure>
<p>安装好后 在xcodeproj文件同级目录下，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fastlane init</div></pre></td></tr></table></figure>
<p>按照提示输入app开发者账号密码等信息 <code>输入后账号密码消息会保存在钥匙串，下次只需要输入账号即可</code></p>
<h3 id="2-Jenkins-fastlane使用"><a href="#2-Jenkins-fastlane使用" class="headerlink" title="2. Jenkins + fastlane使用"></a>2. Jenkins + fastlane使用</h3><p>Fastlane是一组命令行工具，可供开发者构建自己的应用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fastlane gym --scheme YourSchemeName</div></pre></td></tr></table></figure>
<p>或运行单元测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fastlane scan --scheme YourSchemeName</div></pre></td></tr></table></figure>
<p>或针对特定设备运行UI测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fastlane scan --scheme UITestsScheme --devices &apos;iPhone 5s&apos;</div></pre></td></tr></table></figure>
<p>甚至可以上传应用进行试运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fastlane pilot upload --ipa PathToIpa</div></pre></td></tr></table></figure>
<h3 id="KIF-测试用例"><a href="#KIF-测试用例" class="headerlink" title="KIF 测试用例"></a>KIF 测试用例</h3><p>在项目中添加测试用例进行UI测试或者接口测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//UI测试</div><div class="line">- (void)test_amg_UI&#123;</div><div class="line">    [tester tapViewWithAccessibilityLabel:@&quot;分类&quot;];</div><div class="line">    [tester tapViewWithAccessibilityLabel:@&quot;护肤品&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//简单的断言测试</div><div class="line">- (void)test_amg_AssertTrue&#123;</div><div class="line">    int a = 3;</div><div class="line">    XCTAssertTrue(a == 0,&quot;a-----0&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fgkka80seuj30zi0k678b.jpg" alt=""></p>
<h4 id="配置好Jenkins后在项目配置中构建输入脚本命令"><a href="#配置好Jenkins后在项目配置中构建输入脚本命令" class="headerlink" title="配置好Jenkins后在项目配置中构建输入脚本命令"></a>配置好Jenkins后在项目配置中构建输入脚本命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fastlane scan --scheme YHInternational</div></pre></td></tr></table></figure>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fgkkaa6ek1j31kw0hc760.jpg" alt=""></p>
<p><strong>注意：</strong> 如果构建是提示<code>command not found</code>需要如下配置环境变量<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fgkkck7l0mj31kw0ukakf.jpg" alt=""></p>
<h4 id="构建后操作"><a href="#构建后操作" class="headerlink" title="构建后操作"></a>构建后操作</h4><p>为了可以直接获取测试报告 在构建后配置如下命令<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fgkka9cs3rj31kw0jtacw.jpg" alt=""><br>每次构建后可以在项目首页看到如下效果<br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fgkka9380pj310i0f80u7.jpg" alt=""><br>点击进去查看信息 也可以进去之后下载zip文件 查看更加好看直观的测试报告<br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fgkka8y0q3j31kw0r40ww.jpg" alt=""><br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fgkka8bugzj31kw0rydni.jpg" alt=""></p>
<h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><ol>
<li>如何在非MVVM架构的代码下有效快捷的编写完善的UI测试用例</li>
<li>如何更快的运行测试代码</li>
</ol>
<h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>结合Android端的情况，看看如何添加monkey测试<br>推荐文章：</p>
<ul>
<li><a href="http://www.infoq.com/cn/articles/actual-combat-of-fastlane-part01" target="_blank" rel="external">Fastlane实战（一）：移动开发自动化之道</a></li>
<li><a href="http://www.infoq.com/cn/articles/fastlane-automatic-testing" target="_blank" rel="external">Fastlane实战（四）：自动化测试篇</a></li>
</ul>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/06/14/Jenkins-fastlane-KIF自动化测试总结/" class="archive-article-date">
  	<time datetime="2017-06-14T03:11:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-06-14</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-YYKit源码阅读知识储备点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/11/YYKit源码阅读知识储备点/">YYKit源码阅读知识储备点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="YYCache-相关知识点"><a href="#YYCache-相关知识点" class="headerlink" title="YYCache 相关知识点"></a>YYCache 相关知识点</h1>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/11/YYKit源码阅读知识储备点/" class="archive-article-date">
  	<time datetime="2017-04-11T09:20:03.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-11</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Block " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>#在block里面, 对数组执行添加操作, 这个数组需要声明成 __block吗</p>
<p>#在block里面, 对NSInteger进行修改, 这个NSInteger是否需要声明成__blcok</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/11/Block /" class="archive-article-date">
  	<time datetime="2017-04-11T02:07:30.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-11</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-《Objective-C-编程之道》读书笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/10/《Objective-C-编程之道》读书笔记/">《Objective-C 编程之道》读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/10/《Objective-C-编程之道》读书笔记/" class="archive-article-date">
  	<time datetime="2017-04-10T10:35:57.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-10</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-我的面试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/07/我的面试题/">我的面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/07/我的面试题/" class="archive-article-date">
  	<time datetime="2017-04-07T09:14:50.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-07</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-《招聘一个靠谱的iOS》面试题参考答案（上）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/07/《招聘一个靠谱的iOS》面试题参考答案（上）/">《招聘一个靠谱的iOS》面试题参考答案（上）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/" target="_blank" rel="external">《招聘一个靠谱的 iOS》</a>—参考答案（上）</p>
<p>说明：面试题来源是<a href="http://weibo.com/u/1364395395" target="_blank" rel="external">微博@我就叫Sunny怎么了</a>的这篇博文：<a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/" target="_blank" rel="external">《招聘一个靠谱的 iOS》</a>，其中共55题，除第一题为纠错题外，其他54道均为简答题。</p>
<p>出题者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。</p>
<p>答案为<a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">微博@iOS程序犭袁</a>整理，未经出题者校对，如有纰漏，请向<a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">微博@iOS程序犭袁</a>指正。</p>
<hr>
<p>#索引</p>
<ol>
<li><p><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#1-风格纠错题" target="_blank" rel="external">风格纠错题</a> </p>
<ol>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#优化部分" target="_blank" rel="external">优化部分</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#硬伤部分" target="_blank" rel="external">硬伤部分</a> </li>
</ol>
</li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#2-什么情况使用-weak-关键字相比-assign-有什么不同" target="_blank" rel="external">什么情况使用 weak 关键字，相比 assign 有什么不同？</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#3-怎么用-copy-关键字" target="_blank" rel="external">怎么用 copy 关键字？</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#4-这个写法会出什么问题-property-copy-nsmutablearray-array" target="_blank" rel="external">这个写法会出什么问题： @property (copy) NSMutableArray *array;</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#5-如何让自己的类用-copy-修饰符如何重写带-copy-关键字的-setter" target="_blank" rel="external"> 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#6-property-的本质是什么ivargettersetter-是如何生成并添加到这个类中的" target="_blank" rel="external">@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#7-protocol-和-category-中如何使用-property" target="_blank" rel="external">@protocol 和 category 中如何使用 @property</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#8-runtime-如何实现-weak-属性" target="_blank" rel="external"> runtime 如何实现 weak 属性</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#9-property中有哪些属性关键字-property-后面可以有哪些修饰符" target="_blank" rel="external">@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#10-weak属性需要在dealloc中置nil么" target="_blank" rel="external"> weak属性需要在dealloc中置nil么？</a></li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#11-synthesize和dynamic分别有什么作用" target="_blank" rel="external">@synthesize和@dynamic分别有什么作用？</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#12-arc下不显式指定任何属性关键字时默认的关键字都有哪些" target="_blank" rel="external">ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#13-用property声明的nsstring或nsarraynsdictionary经常使用copy关键字为什么如果改用strong关键字可能造成什么问题" target="_blank" rel="external">用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</a> <ol>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#1-对非集合类对象的copy操作" target="_blank" rel="external">对非集合类对象的copy操作</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#2集合类对象的copy与mutablecopy" target="_blank" rel="external">集合类对象的copy与mutableCopy</a> </li>
</ol>
</li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#14-synthesize合成实例变量的规则是什么假如property名为foo存在一个名为_foo的实例变量那么还会自动合成新变量么" target="_blank" rel="external">@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#15-在有了自动合成属性实例变量之后synthesize还有哪些使用场景" target="_blank" rel="external">在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#16-objc中向一个nil对象发送消息将会发生什么" target="_blank" rel="external">objc中向一个nil对象发送消息将会发生什么？</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#17-objc中向一个对象发送消息obj-foo和objc_msgsend函数之间有什么关系" target="_blank" rel="external">objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#18-什么时候会报unrecognized-selector的异常" target="_blank" rel="external">什么时候会报unrecognized selector的异常？</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#19-一个objc对象如何进行内存布局考虑有父类的情况" target="_blank" rel="external">一个objc对象如何进行内存布局？（考虑有父类的情况）</a> </li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#20-一个objc对象的isa的指针指向什么有什么作用" target="_blank" rel="external">一个objc对象的isa的指针指向什么？有什么作用？</a></li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md#21-下面的代码输出什么" target="_blank" rel="external">下面的代码输出什么？</a> </li>
</ol>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@implementation Son : Father</div><div class="line">- (id)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</div><div class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<ol>
<li>22–55题，请看下篇。</li>
</ol>
<p>###1. 风格纠错题<br><img src="http://i.imgur.com/O7Zev94.png" alt="enter image description here"><br>修改完的代码：</p>
<p>修改方法有很多种，现给出一种做示例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// .h文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 修改完的代码，这是第一种修改方法，后面会给出第二种修改方法</div><div class="line"></div><div class="line">typedef NS_ENUM(NSInteger, CYLSex) &#123;</div><div class="line">    CYLSexMan,</div><div class="line">    CYLSexWoman</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface CYLUser : NSObject&lt;NSCopying&gt;</div><div class="line"></div><div class="line">@property (nonatomic, readonly, copy) NSString *name;</div><div class="line">@property (nonatomic, readonly, assign) NSUInteger age;</div><div class="line">@property (nonatomic, readonly, assign) CYLSex sex;</div><div class="line"></div><div class="line">- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</div><div class="line">+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>下面对具体修改的地方，分两部分做下介绍：<strong><em>硬伤部分</em></strong>和<strong><em>优化部分</em></strong><br>。因为<strong><em>硬伤部分</em></strong>没什么技术含量，为了节省大家时间，放在后面讲，大神请直接看<strong><em>优化部分</em></strong>。</p>
<p>####<strong><em>优化部分</em></strong></p>
<ol>
<li><p>enum 建议使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 宏来定义枚举类型，参见官方的 <a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html" target="_blank" rel="external">Adopting Modern Objective-C</a> 一文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//定义一个枚举</div><div class="line">	typedef NS_ENUM(NSInteger, CYLSex) &#123;</div><div class="line">	    CYLSexMan,</div><div class="line">	    CYLSexWoman</div><div class="line">	&#125;;</div></pre></td></tr></table></figure>
<p>（仅仅让性别包含男和女可能并不严谨，最严谨的做法可以参考 <a href="https://github.com/ChenYilong/iOSInterviewQuestions/issues/9" target="_blank" rel="external">这里</a> 。）</p>
</li>
<li><p>age 属性的类型：应避免使用基本类型，建议使用 Foundation 数据类型，对应关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int -&gt; NSInteger</div><div class="line">unsigned -&gt; NSUInteger</div><div class="line">float -&gt; CGFloat</div><div class="line">动画时间 -&gt; NSTimeInterval</div></pre></td></tr></table></figure>
</li>
</ol>
<p>同时考虑到 age 的特点，应使用 NSUInteger ，而非 int 。<br>这样做的是基于64-bit 适配考虑，详情可参考出题者的博文<a href="http://blog.sunnyxx.com/2014/12/20/64-bit-tips/" target="_blank" rel="external">《64-bit Tips》</a>。</p>
<ol>
<li>如果工程项目非常庞大，需要拆分成不同的模块，可以在类、typedef宏命名的时候使用前缀。</li>
<li>doLogIn方法不应写在该类中： <p><del>虽然<code>LogIn</code>的命名不太清晰，但笔者猜测是login的意思， （勘误：Login是名词，LogIn 是动词，都表示登陆的意思。见： <a href="http://grammarist.com/spelling/log-in-login/" target="_blank" rel="external"> <strong><em>Log in vs. login</em></strong> </a>）</del></p>登录操作属于业务逻辑，观察类名 UserModel ，以及属性的命名方式，该类应该是一个 Model 而不是一个“ MVVM 模式下的 ViewModel ”：</li>
</ol>
<blockquote>
<p>无论是 MVC 模式还是 MVVM 模式，业务逻辑都不应当写在 Model 里：MVC 应在 C，MVVM 应在 VM。</p>
</blockquote>
<p> （如果抛开命名规范，假设该类真的是 MVVM 模式里的 ViewModel ，那么 UserModel 这个类可能对应的是用户注册页面，如果有特殊的业务需求，比如： <code>-logIn</code> 对应的应当是注册并登录的一个 Button ，出现 <code>-logIn</code> 方法也可能是合理的。）</p>
<ol>
<li><p>doLogIn 方法命名不规范：添加了多余的动词前缀。<br>请牢记：</p>
<blockquote>
<p>如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用 <code>do</code>，<code>does</code> 这种多余的关键字，动词本身的暗示就足够了。</p>
</blockquote>
<p>应为 <code>-logIn</code> （注意： <code>Login</code> 是名词， <code>LogIn</code>  是动词，都表示登陆。  见<a href="http://grammarist.com/spelling/log-in-login/" target="_blank" rel="external"> <strong><em>Log in vs. login</em></strong> </a>）</p>
</li>
<li><p><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中不要用 <code>with</code> 来连接两个参数: <code>withAge:</code> 应当换为<code>age:</code>，<code>age:</code> 已经足以清晰说明参数的作用，也不建议用 <code>andAge:</code> ：通常情况下，即使有类似 <code>withA:withB:</code> 的命名需求，也通常是使用<code>withA:andB:</code> 这种命名，用来表示方法执行了两个相对独立的操作（<em>从设计上来说，这时候也可以拆分成两个独立的方法</em>），它不应该用作阐明有多个参数，比如下面的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//错误，不要使用&quot;and&quot;来连接参数</div><div class="line">- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;</div><div class="line">//错误，不要使用&quot;and&quot;来阐明有多个参数</div><div class="line">- (instancetype)initWithName:(CGFloat)width andAge:(CGFloat)height;</div><div class="line">//正确，使用&quot;and&quot;来表示两个相对独立的操作</div><div class="line">- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;</div></pre></td></tr></table></figure>
</li>
<li><p>由于字符串值可能会改变，所以要把相关属性的“内存管理语义”声明为 copy 。(原因在下文有详细论述：<strong><em>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？</em></strong>)</p>
</li>
<li><p>“性别”(sex）属性的：该类中只给出了一种“初始化方法” (initializer)用于设置“姓名”(Name)和“年龄”(Age)的初始值，那如何对“性别”(Sex）初始化？</p>
<p>Objective-C 有 designated 和 secondary 初始化方法的观念。 designated 初始化方法是提供所有的参数，secondary 初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用 designated 初始化方法的初始化方法。举例说明：</p>
</li>
</ol>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// .m文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">//</div><div class="line"></div><div class="line">@implementation CYLUser</div><div class="line"></div><div class="line">- (instancetype)initWithName:(NSString *)name</div><div class="line">                         age:(NSUInteger)age</div><div class="line">                         sex:(CYLSex)sex &#123;</div><div class="line">    if(self = [super init]) &#123;</div><div class="line">        _name = [name copy];</div><div class="line">        _age = age;</div><div class="line">        _sex = sex;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithName:(NSString *)name</div><div class="line">                         age:(NSUInteger)age &#123;</div><div class="line">    return [self initWithName:name age:age sex:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p> 上面的代码中initWithName:age:sex: 就是 designated 初始化方法，另外的是 secondary 初始化方法。因为仅仅是调用类实现的 designated 初始化方法。</p>
<p>  因为出题者没有给出 <code>.m</code> 文件，所以有两种猜测：1：本来打算只设计一个 designated 初始化方法，但漏掉了“性别”(sex）属性。那么最终的修改代码就是上文给出的第一种修改方法。2：不打算初始时初始化“性别”(sex）属性，打算后期再修改，如果是这种情况，那么应该把“性别”(sex）属性设为 readwrite 属性，最终给出的修改代码应该是：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">// .h文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 第二种修改方法（基于第一种修改方法的基础上）</div><div class="line"></div><div class="line">typedef NS_ENUM(NSInteger, CYLSex) &#123;</div><div class="line">    CYLSexMan,</div><div class="line">    CYLSexWoman</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface CYLUser : NSObject&lt;NSCopying&gt;</div><div class="line"></div><div class="line">@property (nonatomic, readonly, copy) NSString *name;</div><div class="line">@property (nonatomic, readonly, assign) NSUInteger age;</div><div class="line">@property (nonatomic, readwrite, assign) CYLSex sex;</div><div class="line"></div><div class="line">- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</div><div class="line">- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age;</div><div class="line">+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>  <code>.h</code> 中暴露 designated 初始化方法，是为了方便子类化 （想了解更多，请戳–》 <a href="http://is.gd/OQ49zk" target="_blank" rel="external"><strong><em>《禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）》</em></strong></a>。）</p>
<ol>
<li>按照接口设计的惯例，如果设计了“初始化方法” (initializer)，也应当搭配一个快捷构造方法。而快捷构造方法的返回值，建议为 instancetype，为保持一致性，init 方法和快捷构造方法的返回类型最好都用 instancetype。</li>
<li>如果基于第一种修改方法：既然该类中已经有一个“初始化方法” (initializer)，用于设置“姓名”(Name)、“年龄”(Age)和“性别”(Sex）的初始值:<br>那么在设计对应 <code>@property</code> 时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。在本例中，仍需声明属性的“内存管理语义”。于是可以把属性的定义改成这样</li>
</ol>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, readonly, copy) NSString *name;</div><div class="line">@property (nonatomic, readonly, assign) NSUInteger age;</div><div class="line">@property (nonatomic, readonly, assign) CYLSex sex;</div></pre></td></tr></table></figure>
<pre><code>由于是只读属性，所以编译器不会为其创建对应的“设置方法”，即便如此，我们还是要写上这些属性的语义，以此表明初始化方法在设置这些属性值时所用的方式。要是不写明语义的话，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而且低效。
</code></pre><ol>
<li><code>initUserModelWithUserName</code> 如果改为 <code>initWithName</code> 会更加简洁，而且足够清晰。</li>
<li><code>UserModel</code> 如果改为 <code>User</code> 会更加简洁，而且足够清晰。</li>
<li><code>UserSex</code>如果改为<code>Sex</code> 会更加简洁，而且足够清晰。</li>
<li><p>第二个 <code>@property</code> 中 assign 和 nonatomic 调换位置。<br>推荐按照下面的格式来定义属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, readwrite, copy) NSString *name;</div></pre></td></tr></table></figure>
<p>属性的参数应该按照下面的顺序排列： 原子性，读写 和 内存管理。 这样做你的属性更容易修改正确，并且更好阅读。这在<a href="https://github.com/oa414/objc-zen-book-cn#属性定义" target="_blank" rel="external">《禅与Objective-C编程艺术 &gt;》</a>里有介绍。而且习惯上修改某个属性的修饰符时，一般从属性名从右向左搜索需要修动的修饰符。最可能从最右边开始修改这些属性的修饰符，根据经验这些修饰符被修改的可能性从高到底应为：内存管理 &gt; 读写权限 &gt;原子操作。</p>
</li>
</ol>
<p>####<strong><em>硬伤部分</em></strong></p>
<ol>
<li>在-和(void)之间应该有一个空格</li>
<li>enum 中驼峰命名法和下划线命名法混用错误：枚举类型的命名规则和函数的命名规则相同：命名时使用驼峰命名法，勿使用下划线命名法。</li>
<li>enum 左括号前加一个空格，或者将左括号换到下一行</li>
<li>enum 右括号后加一个空格</li>
<li><code>UserModel :NSObject</code> 应为<code>UserModel : NSObject</code>，也就是<code>:</code>右侧少了一个空格。</li>
<li><code>@interface</code> 与 <code>@property</code> 属性声明中间应当间隔一行。</li>
<li>两个方法定义之间不需要换行，有时为了区分方法的功能也可间隔一行，但示例代码中间隔了两行。</li>
<li><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中方法名与参数之间多了空格。而且 <code>-</code> 与 <code>(id)</code> 之间少了空格。</li>
<li><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中方法名与参数之间多了空格：<code>(NSString*)name</code> 前多了空格。</li>
<li><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code> 方法中 <code>(NSString*)name</code>,应为 <code>(NSString *)name</code>，少了空格。 </li>
<li><p><del>doLogIn方法中的 <code>LogIn</code> 命名不清晰：笔者猜测是login的意思，应该是粗心手误造成的。<br>（勘误： <code>Login</code> 是名词， <code>LogIn</code>  是动词，都表示登陆的意思。见： <a href="http://grammarist.com/spelling/log-in-login/" target="_blank" rel="external"> <strong><em>Log in vs. login</em></strong> </a>）</del></p>

</li>
</ol>
<p>###2. 什么情况使用 weak 关键字，相比 assign 有什么不同？<br>什么情况使用 weak 关键字？</p>
<ol>
<li><p>在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性</p>
</li>
<li><p>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：<strong><em>《IBOutlet连出来的视图属性为什么可以被设置成weak?》</em></strong></p>
</li>
</ol>
<p>不同点：</p>
<ol>
<li><p><code>weak</code> 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，<br>然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。<br>而 <code>assign</code> 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或<br>NSlnteger 等)的简单赋值操作。</p>
</li>
<li><p>assign 可以用非 OC 对象,而 weak 必须用于 OC 对象</p>
</li>
</ol>
<p>###3. 怎么用 copy 关键字？<br>用途：</p>
<ol>
<li>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</li>
<li><p>block 也经常使用 copy 关键字，具体原因见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12" target="_blank" rel="external">官方文档：<strong><em>Objects Use Properties to Keep Track of Blocks</em></strong></a>：</p>
<p>block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。你也许会感觉我这种做法有些怪异，不需要写依然写。如果你这样想，其实是你“日用而不知”，你平时开发中是经常在用我说的这种做法的，比如下面的属性不写copy也行，但是你会选择写还是不写呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) NSString *userId;</div><div class="line"></div><div class="line">- (instancetype)initWithUserId:(NSString *)userId &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    _userId = [userId copy];</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/VlVKl8L.png" alt="enter image description here"></p>
</li>
</ol>
<p>下面做下解释：<br> copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。<br>当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>
<blockquote>
<p>用 <code>@property</code> 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>
</blockquote>
<p>该问题在下文中也有论述：<strong><em>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</em></strong></p>
<p>###4. 这个写法会出什么问题： <code>@property (copy) NSMutableArray *array;</code><br>两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ； </p>
<p>第1条的相关原因在下文中有论述<strong><em>《用@property声明的NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？》</em></strong> 以及上文<strong><em>《怎么用 copy 关键字？》</em></strong>也有论述。</p>
<p>比如下面的代码就会发生崩溃</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// .h文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 下面的代码就会发生崩溃</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSMutableArray *mutableArray;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// .m文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 下面的代码就会发生崩溃</div><div class="line"></div><div class="line">NSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];</div><div class="line">self.mutableArray = array;</div><div class="line">[self.mutableArray removeObjectAtIndex:0];</div></pre></td></tr></table></figure>
<p>接下来就会奔溃：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460</div></pre></td></tr></table></figure>
<p>第2条原因，如下：</p>
<blockquote>
<p>该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。</p>
</blockquote>
<p>在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。</p>
<p>在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。</p>
<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。</p>
<p>因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用<br> atomic 属性通常都不会有性能瓶颈。</p>
<p>###5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</p>
<blockquote>
<p>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 <code>NSCopying</code> 与 <code>NSMutableCopying</code> 协议。</p>
</blockquote>
<p>具体步骤：</p>
<ol>
<li>需声明该类遵从 NSCopying 协议</li>
<li><p>实现 NSCopying 协议。该协议只有一个方法: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)copyWithZone:(NSZone *)zone;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。</p>
<p>以第一题的代码为例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// .h文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 修改完的代码</div><div class="line"></div><div class="line">typedef NS_ENUM(NSInteger, CYLSex) &#123;</div><div class="line">    CYLSexMan,</div><div class="line">    CYLSexWoman</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface CYLUser : NSObject&lt;NSCopying&gt;</div><div class="line"></div><div class="line">@property (nonatomic, readonly, copy) NSString *name;</div><div class="line">@property (nonatomic, readonly, assign) NSUInteger age;</div><div class="line">@property (nonatomic, readonly, assign) CYLSex sex;</div><div class="line"></div><div class="line">- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</div><div class="line">+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>然后实现协议中规定的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (id)copyWithZone:(NSZone *)zone &#123;</div><div class="line">	CYLUser *copy = [[[self class] allocWithZone:zone] </div><div class="line">		             initWithName:_name</div><div class="line"> 							      age:_age</div><div class="line">						          sex:_sex];</div><div class="line">	return copy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如 CYLUser 中含有一个数组，与其他 CYLUser 对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// .h文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 以第一题《风格纠错题》里的代码为例</div><div class="line"></div><div class="line">typedef NS_ENUM(NSInteger, CYLSex) &#123;</div><div class="line">    CYLSexMan,</div><div class="line">    CYLSexWoman</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@interface CYLUser : NSObject&lt;NSCopying&gt;</div><div class="line"></div><div class="line">@property (nonatomic, readonly, copy) NSString *name;</div><div class="line">@property (nonatomic, readonly, assign) NSUInteger age;</div><div class="line">@property (nonatomic, readonly, assign) CYLSex sex;</div><div class="line"></div><div class="line">- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</div><div class="line">+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</div><div class="line">- (void)addFriend:(CYLUser *)user;</div><div class="line">- (void)removeFriend:(CYLUser *)user;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>// .m文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">// .m文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">//</div><div class="line"></div><div class="line">@implementation CYLUser &#123;</div><div class="line">    NSMutableSet *_friends;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setName:(NSString *)name &#123;</div><div class="line">    _name = [name copy];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithName:(NSString *)name</div><div class="line">                         age:(NSUInteger)age</div><div class="line">                         sex:(CYLSex)sex &#123;</div><div class="line">    if(self = [super init]) &#123;</div><div class="line">        _name = [name copy];</div><div class="line">        _age = age;</div><div class="line">        _sex = sex;</div><div class="line">        _friends = [[NSMutableSet alloc] init];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addFriend:(CYLUser *)user &#123;</div><div class="line">    [_friends addObject:user];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeFriend:(CYLUser *)user &#123;</div><div class="line">    [_friends removeObject:user];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)copyWithZone:(NSZone *)zone &#123;</div><div class="line">    CYLUser *copy = [[[self class] allocWithZone:zone]</div><div class="line">                     initWithName:_name</div><div class="line">                     age:_age</div><div class="line">                     sex:_sex];</div><div class="line">    copy-&gt;_friends = [_friends mutableCopy];</div><div class="line">    return copy;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)deepCopy &#123;</div><div class="line">    CYLUser *copy = [[[self class] allocWithZone:zone]</div><div class="line">                     initWithName:_name</div><div class="line">                     age:_age</div><div class="line">                     sex:_sex];</div><div class="line">    copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends</div><div class="line">                                             copyItems:YES];</div><div class="line">    return copy;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>以上做法能满足基本的需求，但是也有缺陷：</p>
<blockquote>
<p>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</p>
</blockquote>
<p>【注：深浅拷贝的概念，在下文中有介绍，详见下文的：<strong><em>用@property声明的 NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？</em></strong>】</p>
<p>在例子中，存放朋友对象的 set 是用 “copyWithZone:” 方法来拷贝的，这种浅拷贝方式不会逐个复制 set 中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (id)deepCopy &#123;</div><div class="line">    CYLUser *copy = [[[self class] allocWithZone:zone]</div><div class="line">                     initWithName:_name</div><div class="line">                     age:_age</div><div class="line">                     sex:_sex];</div><div class="line">    copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends</div><div class="line">                                             copyItems:YES];</div><div class="line">    return copy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于<strong><em>如何重写带 copy 关键字的 setter</em></strong>这个问题，</p>
<p>如果抛开本例来回答的话，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)setName:(NSString *)name &#123;</div><div class="line">    //[_name release];</div><div class="line">    _name = [name copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过也有争议，有人说“苹果如果像下面这样干，是不是效率会高一些？”</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)setName:(NSString *)name &#123;</div><div class="line">    if (_name != name) &#123;</div><div class="line">        //[_name release];//MRC</div><div class="line">        _name = [name copy];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样真得高效吗？不见得！这种写法“看上去很美、很合理”，但在实际开发中，它更像下图里的做法：</p>
<p><img src="http://i.imgur.com/UwV9oSn.jpeg" alt="enter image description here"></p>
<p>克强总理这样评价你的代码风格：</p>
<p><img src="http://i.imgur.com/N77Lkic.png" alt="enter image description here"></p>
<p>我和总理的意见基本一致：</p>
<blockquote>
<p>老百姓 copy 一下，咋就这么难？</p>
</blockquote>
<p>你可能会说：</p>
<p>之所以在这里做<code>if判断</code> 这个操作：是因为一个 if 可能避免一个耗时的copy，还是很划算的。<br>(在刚刚讲的：《如何让自己的类用 copy 修饰符？》里的那种复杂的copy，我们可以称之为 “耗时的copy”，但是对 NSString 的 copy 还称不上。)</p>
<p>但是你有没有考虑过代价：</p>
<blockquote>
<p>你每次调用 <code>setX:</code> 都会做 if 判断，这会让 <code>setX:</code> 变慢，如果你在 <code>setX:</code>写了一串复杂的 <code>if+elseif+elseif+...</code> 判断，将会更慢。</p>
</blockquote>
<p>要回答“哪个效率会高一些？”这个问题，不能脱离实际开发，就算 copy 操作十分耗时，if 判断也不见得一定会更快，除非你把一个“ @property他当前的值 ”赋给了他自己，代码看起来就像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[a setX:x1];</div><div class="line">[a setX:x1];    //你确定你要这么干？与其在setter中判断，为什么不把代码写好？</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[a setX:[a x]];   //队友咆哮道：你在干嘛？！！</div></pre></td></tr></table></figure>
<blockquote>
<p>不要在 setter 里进行像 <code>if(_obj != newObj)</code> 这样的判断。（该观点参考链接：<a href="http://vgable.com/blog/tag/autorelease/" target="_blank" rel="external"> <strong><em>How To Write Cocoa Object Setters： Principle 3: Only Optimize After You Measure</em></strong> </a><br>）</p>
</blockquote>
<p>什么情况会在 copy setter 里做 if 判断？<br>例如，车速可能就有最高速的限制，车速也不可能出现负值，如果车子的最高速为300，则 setter 的方法就要改写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-(void)setSpeed:(int)_speed&#123;</div><div class="line">    if(_speed &lt; 0) speed = 0;</div><div class="line">    if(_speed &gt; 300) speed = 300;</div><div class="line">    _speed = speed;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回到这个题目，如果单单就上文的代码而言，我们不需要也不能重写 name 的 setter ：由于是 name 是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”–copy，是因为：如果不写 copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效）。</p>
<p>那如何确保 name 被 copy？在初始化方法(initializer)中做：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithName:(NSString *)name </div><div class="line">							 age:(NSUInteger)age </div><div class="line">							 sex:(CYLSex)sex &#123;</div><div class="line">     if(self = [super init]) &#123;</div><div class="line">     	_name = [name copy];</div><div class="line">     	_age = age;</div><div class="line">     	_sex = sex;</div><div class="line">     	_friends = [[NSMutableSet alloc] init];</div><div class="line">     &#125;</div><div class="line">     return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</p>
<p><strong>@property 的本质是什么？</strong></p>
<blockquote>
<p>@property = ivar + getter + setter;</p>
</blockquote>
<p>下面解释下：</p>
<blockquote>
<p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p>
</blockquote>
<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 <code>Objective-C 2.0</code> 的一部分。<br>而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。<br>正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>
<blockquote>
<p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。<br>所以你也可以这么说：</p>
<p>@property = getter + setter;</p>
</blockquote>
<p>例如下面这个类：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line">@property NSString *firstName;</div><div class="line">@property NSString *lastName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上述代码写出来的类与下面这种写法等效：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line">- (NSString *)firstName;</div><div class="line">- (void)setFirstName:(NSString *)firstName;</div><div class="line">- (NSString *)lastName;</div><div class="line">- (void)setLastName:(NSString *)lastName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><strong>ivar、getter、setter 是如何生成并添加到这个类中的?</strong></p>
<blockquote>
<p>“自动合成”( autosynthesis)</p>
</blockquote>
<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译<br>器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为<br> <code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过<br> <code>@synthesize</code> 语法来指定实例变量的名字.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@implementation Person</div><div class="line">@synthesize firstName = _myFirstName;</div><div class="line">@synthesize lastName = _myLastName;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</p>
<ol>
<li><code>OBJC_IVAR_$类名$属性名称</code> ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</li>
<li>setter 与 getter 方法对应的实现函数</li>
<li><code>ivar_list</code> ：成员变量列表</li>
<li><code>method_list</code> ：方法列表</li>
<li><code>prop_list</code> ：属性列表</li>
</ol>
<p>也就是说我们每次在增加一个属性,系统都会在 <code>ivar_list</code> 中添加一个成员变量的描述,在 <code>method_list</code> 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>
<p>###7. @protocol 和 category 中如何使用 @property</p>
<ol>
<li>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</li>
<li><p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：</p>
<ol>
<li><code>objc_setAssociatedObject</code></li>
<li><code>objc_getAssociatedObject</code></li>
</ol>
</li>
</ol>
<p>###8. runtime 如何实现 weak 属性</p>
<p>要实现 weak 属性，首先要搞清楚 weak 属性的特点：</p>
<blockquote>
<p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p>
</blockquote>
<p>那么 runtime 如何实现 weak 变量的自动置nil？</p>
<blockquote>
<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>
</blockquote>
<p>（注：在下文的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到<code>__weak</code>引用的解除时间。）</p>
<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>
<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p>
<p><code>objc_storeWeak</code>函数把第二个参数–赋值对象（b）的内存地址作为键值key，将第一个参数–weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p>
<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p>
<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>
<p>而如果a是由 assign 修饰的，则：<br>在 b 非 nil 时，a 和 b 指向同一个内存地址，在 b 变 nil 时，a 还是指向该内存地址，变野指针。此时向 a 发送消息极易崩溃。</p>
<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 使用伪代码模拟：runtime如何实现weak属性</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line"></div><div class="line"> id obj1;</div><div class="line"> objc_initWeak(&amp;obj1, obj);</div><div class="line">/*obj引用计数变为0，变量作用域结束*/</div><div class="line"> objc_destroyWeak(&amp;obj1);</div></pre></td></tr></table></figure>
<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p>
<p>总体说来，作用是：<br>通过<code>objc_initWeak</code>函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p>
<p>下面分别介绍下方法的内部实现：</p>
<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj1 = 0；</div><div class="line">obj_storeWeak(&amp;obj1, obj);</div></pre></td></tr></table></figure>
<p>也就是说：</p>
<blockquote>
<p> weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p>
</blockquote>
<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p>
<p><code>objc_storeWeak(&amp;obj1, 0);</code></p>
<p>前面的源代码与下列源代码相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 使用伪代码模拟：runtime如何实现weak属性</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line"></div><div class="line">id obj1;</div><div class="line">obj1 = 0;</div><div class="line">objc_storeWeak(&amp;obj1, obj);</div><div class="line">/* ... obj的引用计数变为0，被置nil ... */</div><div class="line">objc_storeWeak(&amp;obj1, 0);</div></pre></td></tr></table></figure>
<p><code>objc_storeWeak</code> 函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从 weak 表中删除，在后面的相关一题会详解。</p>
<p>使用伪代码是为了方便理解，下面我们“真枪实弹”地实现下：</p>
<blockquote>
<p>如何让不使用weak修饰的@property，拥有weak的效果。</p>
</blockquote>
<p>我们从setter方法入手：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setObject:(NSObject *)object</div><div class="line">&#123;</div><div class="line">    objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN);</div><div class="line">    [object cyl_runAtDealloc:^&#123;</div><div class="line">        _object = nil;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是有两个步骤：</p>
<ol>
<li>在setter方法中做如下设置：</li>
</ol>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN);</div></pre></td></tr></table></figure>
<ol>
<li><p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助 runtime：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//要销毁的目标对象</div><div class="line">id objectToBeDeallocated;</div><div class="line">//可以理解为一个“事件”：当上面的目标对象销毁时，同时要发生的“事件”。</div><div class="line">id objectWeWantToBeReleasedWhenThatHappens;</div><div class="line">objc_setAssociatedObject(objectToBeDeallocted,</div><div class="line">                         someUniqueKey,</div><div class="line">                         objectWeWantToBeReleasedWhenThatHappens,</div><div class="line">                         OBJC_ASSOCIATION_RETAIN);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>知道了思路，我们就开始实现 <code>cyl_runAtDealloc</code> 方法，实现过程分两部分：</p>
<p>第一部分：创建一个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助 block 执行“事件”。</p>
<p>// .h文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// .h文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</div><div class="line"></div><div class="line">typedef void (^voidBlock)(void);</div><div class="line"></div><div class="line">@interface CYLBlockExecutor : NSObject</div><div class="line"></div><div class="line">- (id)initWithBlock:(voidBlock)block;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>// .m文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// .m文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</div><div class="line"></div><div class="line">#import &quot;CYLBlockExecutor.h&quot;</div><div class="line"></div><div class="line">@interface CYLBlockExecutor() &#123;</div><div class="line">    voidBlock _block;</div><div class="line">&#125;</div><div class="line">@implementation CYLBlockExecutor</div><div class="line"></div><div class="line">- (id)initWithBlock:(voidBlock)aBlock</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    </div><div class="line">    if (self) &#123;</div><div class="line">        _block = [aBlock copy];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc</div><div class="line">&#123;</div><div class="line">    _block ? _block() : nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>第二部分：核心代码：利用runtime实现<code>cyl_runAtDealloc</code>方法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">// CYLNSObject+RunAtDealloc.h文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 利用runtime实现cyl_runAtDealloc方法</div><div class="line"></div><div class="line">#import &quot;CYLBlockExecutor.h&quot;</div><div class="line"></div><div class="line">const void *runAtDeallocBlockKey = &amp;runAtDeallocBlockKey;</div><div class="line"></div><div class="line">@interface NSObject (CYLRunAtDealloc)</div><div class="line"></div><div class="line">- (void)cyl_runAtDealloc:(voidBlock)block;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">// CYLNSObject+RunAtDealloc.m文件</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 利用runtime实现cyl_runAtDealloc方法</div><div class="line"></div><div class="line">#import &quot;CYLNSObject+RunAtDealloc.h&quot;</div><div class="line">#import &quot;CYLBlockExecutor.h&quot;</div><div class="line"></div><div class="line">@implementation NSObject (CYLRunAtDealloc)</div><div class="line"></div><div class="line">- (void)cyl_runAtDealloc:(voidBlock)block</div><div class="line">&#123;</div><div class="line">    if (block) &#123;</div><div class="line">        CYLBlockExecutor *executor = [[CYLBlockExecutor alloc] initWithBlock:block];</div><div class="line">        </div><div class="line">        objc_setAssociatedObject(self,</div><div class="line">                                 runAtDeallocBlockKey,</div><div class="line">                                 executor,</div><div class="line">                                 OBJC_ASSOCIATION_RETAIN);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>使用方法：<br>导入</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &quot;CYLNSObject+RunAtDealloc.h&quot;</div></pre></td></tr></table></figure>
<p>然后就可以使用了：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSObject *foo = [[NSObject alloc] init];</div><div class="line"></div><div class="line">[foo cyl_runAtDealloc:^&#123;</div><div class="line">    NSLog(@&quot;正在释放foo!&quot;);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>如果对 <code>cyl_runAtDealloc</code> 的实现原理有兴趣，可以看下这篇博文 <a href="http://stackoverflow.com/a/31560217/3395008" target="_blank" rel="external"><strong><em>Fun With the Objective-C Runtime: Run Code at Deallocation of Any Object</em></strong></a></p>
<p>###9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？<br>属性可以拥有的特质分为四类:</p>
<ol>
<li><p>原子性— <code>nonatomic</code> 特质</p>
<p>在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p>
</li>
<li><p>读/写权限—<code>readwrite(读写)</code>、<code>readonly (只读)</code></p>
</li>
<li>内存管理语义—<code>assign</code>、<code>strong</code>、 <code>weak</code>、<code>unsafe_unretained</code>、<code>copy</code></li>
<li><p>方法名—<code>getter=&lt;name&gt;</code> 、<code>setter=&lt;name&gt;</code></p>
<p><code>getter=&lt;name&gt;</code>的样式：</p>
</li>
</ol>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, getter=isOn) BOOL on;</div></pre></td></tr></table></figure>
 <p><del>（ <code>setter=&lt;name&gt;</code>这种不常用，也不推荐使用。故不在这里给出写法。）<br></del></p>


<p> <code>setter=&lt;name&gt;</code>一般用在特殊的情境下，比如：</p>
<p>在数据反序列化、转模型的过程中，服务器返回的字段如果以 <code>init</code> 开头，所以你需要定义一个 <code>init</code> 开头的属性，但默认生成的 <code>setter</code> 与 <code>getter</code> 方法也会以 <code>init</code> 开头，而编译器会把所有以 <code>init</code> 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。</p>
<p>这时你就可以使用下面的方式来避免编译器报错：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy;</div></pre></td></tr></table></figure>
<p>另外也可以用关键字进行特殊说明，来避免编译器报错：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic, readwrite, copy, null_resettable) NSString *initBy;</div><div class="line">- (NSString *)initBy __attribute__((objc_method_family(none)));</div></pre></td></tr></table></figure>
<ol>
<li>不常用的：<code>nonnull</code>,<code>null_resettable</code>,<code>nullable</code></li>
</ol>
<p>###10. weak属性需要在dealloc中置nil么？<br>不需要。</p>
<blockquote>
<p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理</p>
</blockquote>
<p>即便是编译器不帮我们做这些，weak也不需要在 dealloc 中置nil：</p>
<p>正如上文的：<strong><em>runtime 如何实现 weak 属性</em></strong> 中提到的：</p>
<p>我们模拟下 weak 的 setter 方法，应该如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setObject:(NSObject *)object</div><div class="line">&#123;</div><div class="line">    objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN);</div><div class="line">    [object cyl_runAtDealloc:^&#123;</div><div class="line">        _object = nil;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也即:</p>
<blockquote>
<p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p>
</blockquote>
<p>###11. @synthesize和@dynamic分别有什么作用？</p>
<ol>
<li>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是<code>@syntheszie var = _var;</code></li>
<li>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。</li>
<li>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 <code>instance.var = someVar</code>，由于缺 setter 方法会导致程序崩溃；或者当运行到 <code>someVar = var</code> 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</li>
</ol>
<p>###12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</p>
<ol>
<li><p>对应基本数据类型默认关键字是</p>
<p>atomic,readwrite,assign</p>
</li>
<li><p>对于普通的 Objective-C 对象</p>
<p>atomic,readwrite,strong</p>
</li>
</ol>
<p>参考链接：</p>
<ol>
<li><p><a href="http://stackoverflow.com/a/15541801/3395008" target="_blank" rel="external"> <strong><em>Objective-C ARC: strong vs retain and weak vs assign</em></strong> </a></p>
</li>
<li><p><a href="http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html" target="_blank" rel="external"> <strong><em>Variable property attributes or Modifiers in iOS</em></strong> </a></p>
</li>
</ol>
<p>###13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</p>
<ol>
<li>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</li>
<li><p>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</p>
<p>copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。<br>当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>
</li>
</ol>
<p>举例说明：</p>
<p>定义一个以 strong 修饰的 array：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic ,readwrite, strong) NSArray *array;</div></pre></td></tr></table></figure>
<p>然后进行下面的操作：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *mutableArray = [[NSMutableArray alloc] init];</div><div class="line">NSArray *array = @[ @1, @2, @3, @4 ];</div><div class="line">self.array = mutableArray;</div><div class="line">[mutableArray removeAllObjects];;</div><div class="line">NSLog(@&quot;%@&quot;,self.array);</div><div class="line"></div><div class="line">[mutableArray addObjectsFromArray:array];</div><div class="line">self.array = [mutableArray copy];</div><div class="line">[mutableArray removeAllObjects];;</div><div class="line">NSLog(@&quot;%@&quot;,self.array);</div></pre></td></tr></table></figure>
<p>打印结果如下所示：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">2015-09-27 19:10:32.523 CYLArrayCopyDmo[10681:713670] (</div><div class="line">)</div><div class="line">2015-09-27 19:10:32.524 CYLArrayCopyDmo[10681:713670] (</div><div class="line">    1,</div><div class="line">    2,</div><div class="line">    3,</div><div class="line">    4</div><div class="line">)</div></pre></td></tr></table></figure>
<p>（详见仓库内附录的 Demo。）</p>
<p>为了理解这种做法，首先要知道，两种情况：</p>
<ol>
<li>对非集合类对象的 copy 与 mutableCopy 操作；</li>
<li>对集合类对象的 copy 与 mutableCopy 操作。</li>
</ol>
<p>####1. 对非集合类对象的copy操作：</p>
<p>在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：</p>
<ul>
<li>[immutableObject copy] // 浅复制</li>
<li>[immutableObject mutableCopy] //深复制</li>
<li>[mutableObject copy] //深复制</li>
<li>[mutableObject mutableCopy] //深复制</li>
</ul>
<p>比如以下代码：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSMutableString *string = [NSMutableString stringWithString:@&quot;origin&quot;];//copy</div><div class="line">NSString *stringCopy = [string copy];</div></pre></td></tr></table></figure>
<p>查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[string appendString:@&quot;origion!&quot;]</div></pre></td></tr></table></figure>
<p>stringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。<br>  集合类对象以此类推。<br>所以，</p>
<blockquote>
<p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>
</blockquote>
<p>####2、集合类对象的copy与mutableCopy</p>
<p>集合类对象是指 NSArray、NSDictionary、NSSet … 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@[@&quot;a&quot;, @&quot;b&quot;], @[@&quot;c&quot;, @&quot;d&quot;]];</div><div class="line">NSArray *copyArray = [array copy];</div><div class="line">NSMutableArray *mCopyArray = [array mutableCopy];</div></pre></td></tr></table></figure>
<p>查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],@&quot;b&quot;,@&quot;c&quot;,nil];</div><div class="line">NSArray *copyArray = [array copy];</div><div class="line">NSMutableArray *mCopyArray = [array mutableCopy];</div></pre></td></tr></table></figure>
<p>查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论：</p>
<p>在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[immutableObject copy] // 浅复制</div><div class="line">[immutableObject mutableCopy] //单层深复制</div><div class="line">[mutableObject copy] //单层深复制</div><div class="line">[mutableObject mutableCopy] //单层深复制</div></pre></td></tr></table></figure>
<p>这个代码结论和非集合类的非常相似。</p>
<p>参考链接：<a href="https://www.zybuluo.com/MicroCai/note/50592" target="_blank" rel="external">iOS 集合的深复制与浅复制</a></p>
<p>###14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为<code>_foo</code>的实例变量，那么还会自动合成新变量么？<br>在回答之前先说明下一个概念：</p>
<blockquote>
<p>实例变量 = 成员变量 ＝ ivar</p>
</blockquote>
<p>这些说法，笔者下文中，可能都会用到，指的是一个东西。</p>
<p>正如<br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6" target="_blank" rel="external">Apple官方文档 <strong><em>You Can Customize Synthesized Instance Variable Names</em></strong></a> 所说：<br><img src="http://i.imgur.com/D6d0zGJ.png" alt="enter image description here"></p>
<p>如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”( auto synthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法” (synthesized method)的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface CYLPerson : NSObject </div><div class="line">@property NSString *firstName; </div><div class="line">@property NSString *lastName; </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在上例中，会生成两个实例变量，其名称分别为<br> <code>_firstName</code> 与 <code>_lastName</code>。也可以在类的实现代码里通过 <code>@synthesize</code> 语法来指定实例变量的名字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@implementation CYLPerson </div><div class="line">@synthesize firstName = _myFirstName; </div><div class="line">@synthesize lastName = _myLastName; </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上述语法会将生成的实例变量命名为 <code>_myFirstName</code> 与 <code>_myLastName</code> ，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>
<p>总结下 @synthesize 合成实例变量的规则，有以下几点：</p>
<ol>
<li><p>如果指定了成员变量的名称,会生成一个指定的名称的成员变量,</p>
</li>
<li><p>如果这个成员已经存在了就不再生成了.</p>
</li>
<li><p>如果是 <code>@synthesize foo;</code> 还会生成一个名称为foo的成员变量，也就是说：</p>
<blockquote>
<p>如果没有指定成员变量的名称会自动生成一个属性同名的成员变量,</p>
</blockquote>
</li>
</ol>
<ol>
<li>如果是 <code>@synthesize foo = _foo;</code> 就不会生成成员变量了.</li>
</ol>
<p>假如 property 名为 foo，存在一个名为 <code>_foo</code> 的实例变量，那么还会自动合成新变量么？<br>不会。如下图：</p>
<p><img src="http://i.imgur.com/t28ge4W.png" alt="enter image description here"></p>
<p>###15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</p>
<p>回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？</p>
<ol>
<li>同时重写了 setter 和 getter 时</li>
<li>重写了只读属性的 getter 时</li>
<li>使用了 @dynamic 时</li>
<li>在 @protocol 中定义的所有属性</li>
<li>在 category 中定义的所有属性</li>
<li><p>重载的属性 </p>
<p>当你在子类中重载了父类中的属性，你必须 使用 <code>@synthesize</code> 来手动合成ivar。</p>
</li>
</ol>
<p>除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理 @property 的所有内容时，你就会尝试通过实现 @property 的所有“存取方法”（the accessor methods）或者使用 <code>@dynamic</code> 来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis（自动合成）。</p>
<p>因为有了 autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于 autosynthesis（自动合成），但是一旦你需要使用ivar，而 autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助 <code>@synthesize</code> 来手动合成 ivar。</p>
<p>其实，<code>@synthesize</code> 语法还有一个应用场景，但是不太建议大家使用：</p>
<p>可以在类的实现代码里通过 <code>@synthesize</code> 语法来指定实例变量的名字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@implementation CYLPerson </div><div class="line">@synthesize firstName = _myFirstName; </div><div class="line">@synthesize lastName = _myLastName; </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上述语法会将生成的实例变量命名为 <code>_myFirstName</code> 与 <code>_myLastName</code>，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>
<p>举例说明：应用场景：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//</div><div class="line">// .m文件</div><div class="line">// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 打开第14行和第17行中任意一行，就可编译成功</div><div class="line"></div><div class="line">@import Foundation;</div><div class="line"></div><div class="line">@interface CYLObject : NSObject</div><div class="line">@property (nonatomic, copy) NSString *title;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation CYLObject &#123;</div><div class="line">    //    NSString *_title;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//@synthesize title = _title;</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _title = @&quot;微博@iOS程序犭袁&quot;;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)title &#123;</div><div class="line">    return _title;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setTitle:(NSString *)title &#123;</div><div class="line">    _title = [title copy];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>结果编译器报错：<br><img src="http://i.imgur.com/fAEGHIo.png" alt="enter image description here"></p>
<p>当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择：</p>
<ol>
<li>要么如第14行：手动创建 ivar</li>
<li>要么如第17行：使用<code>@synthesize foo = _foo;</code> ，关联 @property 与 ivar。</li>
</ol>
<p>更多信息，请戳- 》<a href="http://stackoverflow.com/a/19821816/3395008" target="_blank" rel="external"> <strong><em>When should I use @synthesize explicitly?</em></strong> </a></p>
<p>###16. objc中向一个nil对象发送消息将会发生什么？<br>在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:</p>
<ol>
<li>如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：  </li>
</ol>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person * motherInlaw = [[aPerson spouse] mother];</div></pre></td></tr></table></figure>
<p> 如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。</p>
<ol>
<li>如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。</li>
<li>如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。</li>
<li>如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。</li>
</ol>
<p>具体原因如下：</p>
<blockquote>
<p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>
</blockquote>
<p>那么，为了方便理解这个内容，还是贴一个objc的源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// runtime.h（类在runtime中的定义）</div><div class="line">// http://weibo.com/luohanchenyilong/</div><div class="line">// https://github.com/ChenYilong</div><div class="line"></div><div class="line">struct objc_class &#123;</div><div class="line">  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</div><div class="line">  #if !__OBJC2__</div><div class="line">  Class super_class OBJC2_UNAVAILABLE; // 父类</div><div class="line">  const char *name OBJC2_UNAVAILABLE; // 类名</div><div class="line">  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0</div><div class="line">  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识</div><div class="line">  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小</div><div class="line">  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表</div><div class="line">  struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表</div><div class="line">  struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</div><div class="line">  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表</div><div class="line">  #endif</div><div class="line">  &#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。<br>那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>
<p>###17. objc中向一个对象发送消息[obj foo]和<code>objc_msgSend()</code>函数之间有什么关系？<br>具体原因同上题：该方法编译之后就是<code>objc_msgSend()</code>函数调用.</p>
<p>我们用 clang 分析下，clang 提供一个命令，可以将Objective-C的源码改写成C++语言，借此可以研究下[obj foo]和<code>objc_msgSend()</code>函数之间有什么关系。</p>
<p>以下面的代码为例，由于 clang 后的代码达到了10万多行，为了便于区分，添加了一个叫 iOSinit 方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  main.m</div><div class="line">//  http://weibo.com/luohanchenyilong/</div><div class="line">//  https://github.com/ChenYilong</div><div class="line">//  Copyright (c) 2015年 微博@iOS程序犭袁. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line"></div><div class="line">#import &quot;CYLTest.h&quot;</div><div class="line"></div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        CYLTest *test = [[CYLTest alloc] init];</div><div class="line">        [test performSelector:(@selector(iOSinit))];</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在终端中输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc main.m</div></pre></td></tr></table></figure>
<p>就可以生成一个<code>main.cpp</code>的文件，在最低端（10万4千行左右）</p>
<p><img src="http://i.imgur.com/eAH5YWn.png" alt="enter image description here"></p>
<p>我们可以看到大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((void ()(id, SEL))(void )objc_msgSend)((id)obj, sel_registerName(&quot;foo&quot;));</div></pre></td></tr></table></figure>
<p>也就是说：</p>
<blockquote>
<p> [obj foo];在objc动态编译时，会被转意为：<code>objc_msgSend(obj, @selector(foo));</code>。</p>
</blockquote>
<p>###18. 什么时候会报unrecognized selector的异常？</p>
<p>简单来说：</p>
<blockquote>
<p>当调用该对象上某个方法,而该对象上没有实现这个方法的时候，<br>可以通过“消息转发”进行解决。</p>
</blockquote>
<p>简单的流程如下，在上一题中也提到过：</p>
<blockquote>
<p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>
</blockquote>
<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</p>
<ol>
<li><p>Method resolution</p>
<p>objc运行时会调用<code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。</p>
</li>
<li><p>Fast forwarding</p>
<p>如果目标对象实现了<code>-forwardingTargetForSelector:</code>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。<br>只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。<br>这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。</p>
</li>
<li><p>Normal forwarding</p>
<p>这一步是Runtime最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回nil，Runtime则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送<code>-forwardInvocation:</code>消息给目标对象。</p>
</li>
</ol>
<p>为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ <code>_objc_msgForward_demo</code> ”,可运行起来看看。</p>
<p>###19. 一个objc对象如何进行内存布局？（考虑有父类的情况）</p>
<ul>
<li>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</li>
<li>每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的</li>
</ul>
<ol>
<li>对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）</li>
<li>成员变量的列表,</li>
<li><p>属性列表,</p>
<p>它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。</p>
</li>
</ol>
<p>每个 Objective-C 对象都有相同的结构，如下图所示：</p>
<p> <img src="http://i.imgur.com/7mJlUj1.png" alt="enter image description here"></p>
<p>翻译过来就是</p>
<table>
<thead>
<tr>
<th></th>
<th>Objective-C 对象的结构图</th>
</tr>
</thead>
<tbody>
<tr>
<td> ISA指针</td>
<td></td>
</tr>
<tr>
<td> 根类的实例变量</td>
<td></td>
</tr>
<tr>
<td> 倒数第二层父类的实例变量</td>
<td></td>
</tr>
<tr>
<td> …</td>
<td></td>
</tr>
<tr>
<td> 父类的实例变量</td>
<td></td>
</tr>
<tr>
<td> 类的实例变量</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><p>根对象就是NSObject，它的superclass指针指向nil</p>
</li>
<li><p>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。</p>
</li>
</ul>
<p>如图:<br><img src="http://i.imgur.com/w6tzFxz.png" alt="enter image description here"></p>
<p>###20. 一个objc对象的isa的指针指向什么？有什么作用？</p>
<p>指向他的类对象,从而可以找到对象上的方法</p>
<p>###21. 下面的代码输出什么？</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@implementation Son : Father</div><div class="line">- (id)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</div><div class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><strong>答案：</strong></p>
<p>都输出 Son</p>
<pre><code>NSStringFromClass([self class]) = Son
NSStringFromClass([super class]) = Son
</code></pre><p>这个题目主要是考察关于 Objective-C 中对 self 和 super 的理解。</p>
<p>我们都知道：self 是类的隐藏参数，指向当前调用方法的这个类的实例。那 super 呢？</p>
<p>很多人会想当然的认为“ super 和 self 类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不同点在于：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>
<p>上面的例子不管调用<code>[self class]</code>还是<code>[super class]</code>，接受消息的对象都是当前 <code>Son ＊xxx</code> 这个对象。</p>
<p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。</p>
<p>这也就是为什么说“不推荐在 init 方法中使用点语法”，如果想访问实例变量 iVar 应该使用下划线（ <code>_iVar</code> ），而非点语法（ <code>self.iVar</code> ）。</p>
<p>点语法（ <code>self.iVar</code> ）的坏处就是子类有可能覆写 setter 。假设 Person 有一个子类叫 ChenPerson，这个子类专门表示那些姓“陈”的人。该子类可能会覆写 lastName 属性所对应的设置方法：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  ChenPerson.m</div><div class="line">//  </div><div class="line">//</div><div class="line">//  Created by https://github.com/ChenYilong on 15/8/30.</div><div class="line">//  Copyright (c) 2015年 http://weibo.com/luohanchenyilong/ 微博@iOS程序犭袁. All rights reserved.</div><div class="line">//</div><div class="line"></div><div class="line">#import &quot;ChenPerson.h&quot;</div><div class="line"></div><div class="line">@implementation ChenPerson</div><div class="line"></div><div class="line">@synthesize lastName = _lastName;</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([self class]));</div><div class="line">        NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([super class]));</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setLastName:(NSString*)lastName</div><div class="line">&#123;</div><div class="line">    //设置方法一：如果setter采用是这种方式，就可能引起崩溃</div><div class="line">//    if (![lastName isEqualToString:@&quot;陈&quot;])</div><div class="line">//    &#123;</div><div class="line">//        [NSException raise:NSInvalidArgumentException format:@&quot;姓不是陈&quot;];</div><div class="line">//    &#125;</div><div class="line">//    _lastName = lastName;</div><div class="line">    </div><div class="line">    //设置方法二：如果setter采用是这种方式，就可能引起崩溃</div><div class="line">    _lastName = @&quot;陈&quot;;</div><div class="line">    NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, @&quot;会调用这个方法,想一下为什么？&quot;);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在基类 Person 的默认初始化方法中，可能会将姓氏设为空字符串。此时若使用点语法（ <code>self.lastName</code> ）也即 setter 设置方法，那么调用将会是子类的设置方法，如果在刚刚的 setter 代码中采用设置方法一，那么就会抛出异常，</p>
<p>为了方便采用打印的方式展示，究竟发生了什么，我们使用设置方法二。</p>
<p>如果基类的代码是这样的：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  Person.m</div><div class="line">//  nil对象调用点语法</div><div class="line">//</div><div class="line">//  Created by https://github.com/ChenYilong on 15/8/29.</div><div class="line">//  Copyright (c) 2015年 http://weibo.com/luohanchenyilong/ 微博@iOS程序犭袁. All rights reserved.</div><div class="line">//  </div><div class="line"></div><div class="line">#import &quot;Person.h&quot;</div><div class="line"></div><div class="line">@implementation Person</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        self.lastName = @&quot;&quot;;</div><div class="line">        //NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([self class]));</div><div class="line">        //NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, self.lastName);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setLastName:(NSString*)lastName</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, @&quot;根本不会调用这个方法&quot;);</div><div class="line">    _lastName = @&quot;炎黄&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>那么打印结果将会是这样的：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">🔴类名与方法名：-[ChenPerson setLastName:]（在第36行），描述：会调用这个方法,想一下为什么？</div><div class="line">🔴类名与方法名：-[ChenPerson init]（在第19行），描述：ChenPerson</div><div class="line">🔴类名与方法名：-[ChenPerson init]（在第20行），描述：ChenPerson</div></pre></td></tr></table></figure>
<p>我在仓库里也给出了一个相应的 Demo（名字叫：Demo<em>21题</em>下面的代码输出什么）。有兴趣可以跑起来看一下，主要看下他是怎么打印的，思考下为什么这么打印。</p>
<p>接下来让我们利用 runtime 的相关知识来验证一下 super 关键字的本质，使用clang重写命令:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ clang -rewrite-objc test.m</div></pre></td></tr></table></figure>
<p>将这道题目中给出的代码被转化为:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;class&quot;))));</div><div class="line"></div><div class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123; (id)self, (id)class_getSuperclass(objc_getClass(&quot;Son&quot;)) &#125;, sel_registerName(&quot;class&quot;))));</div></pre></td></tr></table></figure>
<p>从上面的代码中，我们可以发现在调用 [self class] 时，会转化成 <code>objc_msgSend</code>函数。看下函数定义：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_msgSend(id self, SEL op, ...)</div></pre></td></tr></table></figure>
<p>我们把 self 做为第一个参数传递进去。</p>
<p>而在调用 [super class]时，会转化成 <code>objc_msgSendSuper</code>函数。看下函数定义:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</div></pre></td></tr></table></figure>
<p>第一个参数是 <code>objc_super</code> 这样一个结构体，其定义如下:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct objc_super &#123;</div><div class="line">	   __unsafe_unretained id receiver;</div><div class="line">	   __unsafe_unretained Class super_class;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>结构体有两个成员，第一个成员是 receiver, 类似于上面的 <code>objc_msgSend</code>函数第一个参数self 。第二个成员是记录当前类的父类是什么。</p>
<p>所以，当调用 ［self class] 时，实际先调用的是 <code>objc_msgSend</code>函数，第一个参数是 Son当前的这个实例，然后在 Son 这个类里面去找 - (Class)class这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 - (Class)class的实现就是返回self的类别，故上述输出结果为 Son。</p>
<p>objc Runtime开源代码对- (Class)class方法的实现:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (Class)class &#123;</div><div class="line">    return object_getClass(self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而当调用 <code>[super class]</code>时，会转换成<code>objc_msgSendSuper函数</code>。第一步先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code> 。<br>第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code> , 实际该函数输出结果为 Father。</p>
<p>第二步是去 Father这个类里去找 <code>- (Class)class</code>，没有，然后去NSObject类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，</p>
<p>此时已经和<code>[self class]</code>调用相同了，故上述输出结果仍然返回 Son。</p>
<p>参考链接：<a href="http://weibo.com/junbbcom" target="_blank" rel="external">微博@Chun_iOS</a>的博文<a href="http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1" target="_blank" rel="external">刨根问底Objective－C Runtime（1）－ Self &amp; Super</a>%5Bnil%5D-self-and-super/)</p>
<p>###22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</p>
<p>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</p>
<p>###23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</p>
<ul>
<li>在ARC下不需要。</li>
<li><p><del> 在MRC中,对于使用retain或copy策略的需要 。</del></p>在MRC下也不需要</li>
</ul>
<blockquote>
<p>无论在MRC下还是ARC下均不需要。</p>
</blockquote>
<p><a href="https://web.archive.org/web/20120818164935/http://developer.apple.com/library/ios/#/web/20120820002100/http://developer.apple.com/library/ios/documentation/cocoa/conceptual/objectivec/Chapters/ocAssociativeReferences.html" target="_blank" rel="external"> <strong><em>2011年版本的Apple API 官方文档 - Associative References</em></strong>  </a> 一节中有一个MRC环境下的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 在MRC下，使用runtime Associate方法关联的对象，不需要在主对象dealloc的时候释放</div><div class="line">// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)</div><div class="line">// https://github.com/ChenYilong</div><div class="line">// 摘自2011年版本的Apple API 官方文档 - Associative References </div><div class="line"></div><div class="line">static char overviewKey;</div><div class="line"> </div><div class="line">NSArray *array =</div><div class="line">    [[NSArray alloc] initWithObjects:@&quot;One&quot;, @&quot;Two&quot;, @&quot;Three&quot;, nil];</div><div class="line">// For the purposes of illustration, use initWithFormat: to ensure</div><div class="line">// the string can be deallocated</div><div class="line">NSString *overview =</div><div class="line">    [[NSString alloc] initWithFormat:@&quot;%@&quot;, @&quot;First three numbers&quot;];</div><div class="line"> </div><div class="line">objc_setAssociatedObject (</div><div class="line">    array,</div><div class="line">    &amp;overviewKey,</div><div class="line">    overview,</div><div class="line">    OBJC_ASSOCIATION_RETAIN</div><div class="line">);</div><div class="line"> </div><div class="line">[overview release];</div><div class="line">// (1) overview valid</div><div class="line">[array release];</div><div class="line">// (2) overview invalid</div></pre></td></tr></table></figure>
<p>文档指出 </p>
<blockquote>
<p>At point 1, the string <code>overview</code> is still valid because the <code>OBJC_ASSOCIATION_RETAIN</code> policy specifies that the array retains the associated object. When the array is deallocated, however (at point 2), <code>overview</code> is released and so in this case also deallocated.</p>
</blockquote>
<p>我们可以看到，在<code>[array release];</code>之后，overview就会被release释放掉了。</p>
<p>既然会被销毁，那么具体在什么时间点？</p>
<blockquote>
<p>根据<a href="https://developer.apple.com/videos/wwdc/2011/#322-video" target="_blank" rel="external"> <strong><em>WWDC 2011, Session 322 (第36分22秒)</em></strong> </a>中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。</p>
</blockquote>
<p>对象的内存销毁时间表，分四个步骤：</p>
<pre><code>// 对象的内存销毁时间表
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
// 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 

 1. 调用 -release ：引用计数变为零
     * 对象正在被销毁，生命周期即将结束.
     * 不能再有新的 __weak 弱引用， 否则将指向 nil.
     * 调用 [self dealloc] 
 2. 子类 调用 -dealloc
     * 继承关系中最底层的子类 在调用 -dealloc
     * 如果是 MRC 代码 则会手动释放实例变量们（iVars）
     * 继承关系中每一层的父类 都在调用 -dealloc
 3. NSObject 调 -dealloc
     * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法
 4. 调用 object_dispose()
     * 为 C++ 的实例变量们（iVars）调用 destructors 
     * 为 ARC 状态下的 实例变量们（iVars） 调用 -release 
     * 解除所有使用 runtime Associate方法关联的对象
     * 解除所有 __weak 引用
     * 调用 free()
</code></pre><p>对象的内存销毁时间表：<a href="http://stackoverflow.com/a/10843510/3395008" target="_blank" rel="external">参考链接</a>。</p>
<p>###24. objc中的类方法和实例方法有什么本质区别和联系？</p>
<p>类方法：</p>
<ol>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中不能访问成员变量</li>
<li>类方法中不能直接调用对象方法</li>
</ol>
<p>实例方法：</p>
<ol>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ol>
<h2 id="下一篇文章将发布在这里，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注微博-iOS程序犭袁"><a href="#下一篇文章将发布在这里，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注微博-iOS程序犭袁" class="headerlink" title="下一篇文章将发布在这里，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注微博@iOS程序犭袁"></a>下一篇文章将发布在<a href="https://github.com/ChenYilong/iOSInterviewQuestions" target="_blank" rel="external">这里</a>，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注<a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">微博@iOS程序犭袁</a></h2><p>@property部分主要参考<br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW2" target="_blank" rel="external">Apple官方文档：Properties Encapsulate an Object’s Values</a><br>runtime部分主要参考<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html" target="_blank" rel="external">Apple官方文档：Declared Properties</a></p>
<p>###25. <code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</p>
<p>###26. runtime如何实现weak变量的自动置nil？</p>
<p>###27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ </p>
<p>###28. runloop和线程有什么关系？</p>
<p>###29. runloop的mode作用是什么？</p>
<p>###30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</p>
<p>###31. 猜想runloop内部是如何实现的？</p>
<p>###32. objc使用什么机制管理对象内存？</p>
<p>###33. ARC通过什么方式帮助开发者管理内存？</p>
<p>###34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</p>
<p>###35. <code>BAD_ACCESS</code>在什么情况下出现？</p>
<p>###36. 苹果是如何实现autoreleasepool的？ </p>
<p>###37. 使用block时什么情况会发生引用循环，如何解决？</p>
<p>###38. 在block内如何修改block外部变量？</p>
<p>###39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？ </p>
<p>###40. GCD的队列（<code>dispatch_queue_t</code>）分哪两种类型？</p>
<p>###41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</p>
<p>###42. <code>dispatch_barrier_async</code>的作用是什么？</p>
<p>###43. 苹果为什么要废弃<code>dispatch_get_current_queue</code>？</p>
<p>###44. 以下代码运行结果如何？</p>
<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];
    NSLog(@&quot;1&quot;);
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@&quot;2&quot;);
    });
    NSLog(@&quot;3&quot;);
}
</code></pre><p>###45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</p>
<p>###46. 如何手动触发一个value的KVO</p>
<p>###47. 若一个类有实例变量<code>NSString *_foo</code>，调用setValue:forKey:时，可以以foo还是<code>_foo</code>作为key？</p>
<p>###48. KVC的keyPath中的集合运算符如何使用？</p>
<p>###49. KVC和KVO的keyPath一定是属性么？</p>
<p>###50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</p>
<p>###51. apple用什么方式实现对一个对象的KVO？ </p>
<p>###52. IBOutlet连出来的视图属性为什么可以被设置成weak?</p>
<p>###53. IB中User Defined Runtime Attributes如何使用？ </p>
<p>###54. 如何调试<code>BAD_ACCESS</code>错误</p>
<p>###55. lldb（gdb）常用的调试命令？</p>
<hr>
<p>Posted by <a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="external">Creative Commons BY-NC-ND 3.0</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/07/《招聘一个靠谱的iOS》面试题参考答案（上）/" class="archive-article-date">
  	<time datetime="2017-04-07T09:02:07.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-07</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-多线程与内存管理读书摘录-Block篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/01/多线程与内存管理读书摘录-Block篇/">多线程与内存管理读书摘录(Block篇)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是Blocks"><a href="#什么是Blocks" class="headerlink" title="什么是Blocks"></a>什么是Blocks</h2><p> Blocks:带有自动变量（局部变量）的匿名函数，匿名函数就是不带有名称的函数。</p>
<h3 id="Block语法"><a href="#Block语法" class="headerlink" title="Block语法"></a>Block语法</h3><p>1.没有函数名</p>
<p>2.带有“^”</p>
<p><code>^</code> <code>返回值类型</code> ``参数列表<figure class="highlight plain"><figcaption><span>表达式``</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3.使用C语言数组时必须小心使用其指针</div></pre></td></tr></table></figure></p>
<pre><code>const char text[] = &quot;hello&quot;;
void (^blk2)(void ) = ^{
    text[2];
};
//error:cannot refer to declaration with an array type inside block
修改
   const char *text = &quot;hello&quot;;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Block的实现</div><div class="line">##### Block的本质</div></pre></td></tr></table></figure>
<p>int main()<br>{<br>void (^blk)(void) = ^{printf(“Block\n”);};<br>blk();<br>return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">clang -rewrite-objc 源代码文件名</div></pre></td></tr></table></figure></p>
<p>变成以下形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/01/多线程与内存管理读书摘录-Block篇/" class="archive-article-date">
  	<time datetime="2017-04-01T01:43:06.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-01</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-模块化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/31/模块化/">模块化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/31/模块化/" class="archive-article-date">
  	<time datetime="2017-03-31T08:37:08.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-31</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-多线程与内存管理读书笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/30/多线程与内存管理读书笔记/">多线程与内存管理读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!--editor:吴至波-->
<h1 id="一-内存管理的思考方式"><a href="#一-内存管理的思考方式" class="headerlink" title="一.内存管理的思考方式"></a>一.内存管理的思考方式</h1><h3 id="1-引用计数的思考方式："><a href="#1-引用计数的思考方式：" class="headerlink" title="1.引用计数的思考方式："></a>1.引用计数的思考方式：</h3><ul>
<li>自己生成的对象，自己持有</li>
<li>非自己生成的对象，自己也能持有</li>
<li>不再需要自己持有的对象时释放</li>
<li><p>非自己持有的对象无法释放</p>
<h5 id="对象操作与Objective-C-方法的对应"><a href="#对象操作与Objective-C-方法的对应" class="headerlink" title="对象操作与Objective-C 方法的对应"></a>对象操作与Objective-C 方法的对应</h5></li>
</ul>
<table>
<thead>
<tr>
<th>对象操作</th>
<th>Objcetive-C 方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>生成并持有对象</td>
<td>alloc/new/copy/mutableCopy 等方法</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain</td>
</tr>
<tr>
<td>释放对象</td>
<td>release</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc</td>
</tr>
</tbody>
</table>
<h4 id="2-alloc-retain-release-dealloc-实现"><a href="#2-alloc-retain-release-dealloc-实现" class="headerlink" title="2.alloc/retain.release/dealloc 实现"></a>2.alloc/retain.release/dealloc 实现</h4><p>GNUstep是Cocoa框架的互换框架。理解了GNUstep源代码也就相当于理解了苹果的Cocoa实现。</p>
<p>a.通过allocWithZone:类方法调用NSAllocateObject函数分配了对象。</p>
<p>b.NSAllocateObject函数通过调用NSZoneMalloc函数来分配存放对象所需的内存空间，之后将改内存空间置0，最后返回作为对象而使用的指针。</p>
<p>c.NSZone:为防止内存碎片化而引入的结构</p>
<h5 id="总结：GNUstep中alloc-retain-release-dealloc-的实现"><a href="#总结：GNUstep中alloc-retain-release-dealloc-的实现" class="headerlink" title="总结：GNUstep中alloc/retain/release/dealloc 的实现"></a>总结：GNUstep中alloc/retain/release/dealloc 的实现</h5><ul>
<li>在Objective-C的对象中存有引用计数这一整数值。</li>
<li>调用alloc或是retain方法后，引用计数值加1</li>
<li>调用release后，引用计数值减1</li>
<li>引用计数值为0时，调用dealloc方法废弃对象</li>
</ul>
<table>
<thead>
<tr>
<th>GNUstep的实现</th>
<th>苹果的实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>将引用计数保存在对象占用内存块头部的变量中</td>
<td>保存在引用计数表的记录中</td>
</tr>
<tr>
<td>少量代码即可完成</td>
<td>对象用内存块的分配无需考虑内存块头部</td>
</tr>
<tr>
<td>能够统一管理引用计数用内存块与对象用内存块</td>
<td>引用计数表各记录中存有内存快地址，可从各个记录追溯到各对象的内存块</td>
</tr>
</tbody>
</table>
<h4 id="3-autorelease理解"><a href="#3-autorelease理解" class="headerlink" title="3.autorelease理解"></a>3.autorelease理解</h4><p>定义：自动释放，当对象实例超出作用域（相当于变量作用域）时，对象实例的release实例方法被调用。</p>
<ul>
<li>生成并持有NSAutoreleasePool对象</li>
<li>调用已分配对象的autorelease实例方法</li>
<li>废弃NSAutoreleasePool对象</li>
</ul>
<h5 id="autorelease实现"><a href="#autorelease实现" class="headerlink" title="autorelease实现"></a>autorelease实现</h5><table>
<thead>
<tr>
<th>GNUstep的实现</th>
<th>苹果的实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>atuorelease实例方法的本质就是调用NSAutoreleasePool对象的addObject方法</td>
<td>通过objc4库的runtime/objc-arr.mm 确认autorelease实现 类似</td>
</tr>
</tbody>
</table>
<h4 id="4-ARC规则"><a href="#4-ARC规则" class="headerlink" title="4.ARC规则"></a>4.ARC规则</h4><h5 id="A-所有权修饰符"><a href="#A-所有权修饰符" class="headerlink" title="A.所有权修饰符"></a>A.所有权修饰符</h5><ul>
<li>__strong 修饰符</li>
<li>__weak 修饰符</li>
<li>__unsafe _unretained 修饰符</li>
<li>__autoreleasing 修饰符</li>
</ul>
<h5 id="1-strong-修饰符"><a href="#1-strong-修饰符" class="headerlink" title="1).__strong 修饰符"></a>1).__strong 修饰符</h5><p><strong>strong 修饰符是id类型和对象类型默认的所有权修饰符，表示对对象的“强引用”。持有强引用的变量在超出其作用域是被废弃，随着强引用的失效，引用的对象会随之释放。通过 </strong>strong 修饰符，不必再次键入retain或者release,完美地满足了 “引用计数式内存管理的思考方式”。</p>
<h5 id="2-weak-修饰符"><a href="#2-weak-修饰符" class="headerlink" title="2).__weak 修饰符"></a>2).__weak 修饰符</h5><p><strong>循环引用容易发生内存泄露。所谓内存泄漏就是应当废弃的对象在超出其生存周期后继续存在</strong></p>
<p>__weak 修饰符的一个优点：在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于nil被赋值的状态（空弱引用）。</p>
<h5 id="3-unsafe-unretained-修饰符"><a href="#3-unsafe-unretained-修饰符" class="headerlink" title="3).__unsafe _unretained 修饰符"></a>3).__unsafe _unretained 修饰符</h5><p><strong>weak 修饰符只能用于iOS5 以上以及OS X Lion 以上版本的应用程序，之下版本使用了 </strong>unsafe _unretained 修饰符。</p>
<p><strong>unsafe _unretained  是不安全的所有权修饰符，附有 </strong>unsafe _unretained 修饰符的变量不属于编译器的内存管理对象。</p>
<h5 id="4-autoreleasing-修饰符"><a href="#4-autoreleasing-修饰符" class="headerlink" title="4).__autoreleasing 修饰符"></a>4).__autoreleasing 修饰符</h5><p>ARC有效时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool&#123;</div><div class="line">   id __autoreleasing obj = [[NSObject alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>指定“@autoreleasepool块”来替代“NSAutoreleasePool类对象生成、持有以及废弃”这一范围。</p>
<p>id的指针或对象的指针会默认附加上__autoreleasing 修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (BOOL) performOperationWithError:(NSError **) error;</div><div class="line">等同于</div><div class="line">- (BOOL) performOperationWithError:(NSError * __autoreleaasing *) error;</div></pre></td></tr></table></figure>
<p>赋值给对象指针是，所有权修饰符必须一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">///正确写法</div><div class="line">NSError *error = nil;</div><div class="line">NSError *__strong *pError = &amp;error;</div></pre></td></tr></table></figure>
<hr>
<p><strong>了解@autoreleasepool</strong></p>
<p>NSRunLoop等实现不论ARC有效还是无效，均能够随时释放注册到autoreleasepool中的对象</p>
<p>autoreleasepool 范围以块级源代码表示，提高了程序的可读性，所以今后在ARC无效时也推荐使用@autoreleasepool块。</p>
<hr>
<h5 id="B-具体的ARC规则"><a href="#B-具体的ARC规则" class="headerlink" title="B.具体的ARC规则"></a>B.具体的ARC规则</h5><ul>
<li>不能使用retain/release/retainCount/autorelease</li>
<li>不能使用NSAllocateObject/NSDeallocateObject</li>
<li>须遵守内存管理的方法命名规则</li>
<li>不要显示调用dealloc</li>
<li>使用@autoreleasepool块替代NSAutoreleasePool</li>
<li>不能使用区域（NSZone)</li>
<li>对象型变量不能作为C语言结构体（struct/union)的成员</li>
<li>显示转换“id”和“void * ”</li>
</ul>
<h5 id="1-不能使用retain-release-retainCount-autorelease"><a href="#1-不能使用retain-release-retainCount-autorelease" class="headerlink" title="1).不能使用retain/release/retainCount/autorelease"></a>1).不能使用retain/release/retainCount/autorelease</h5><p>设置ARC有效时，无需（禁止）再次键入retain或release代码</p>
<p>即使ARC被设置为无效时，该源代码也完全不符合引用计数式内存管理的思考方式。</p>
<h5 id="2-不能使用NSAllocateObject-NSDeallocateObject"><a href="#2-不能使用NSAllocateObject-NSDeallocateObject" class="headerlink" title="2).不能使用NSAllocateObject/NSDeallocateObject"></a>2).不能使用NSAllocateObject/NSDeallocateObject</h5><h5 id="3-须遵守内存管理的方法命名规则"><a href="#3-须遵守内存管理的方法命名规则" class="headerlink" title="3).须遵守内存管理的方法命名规则"></a>3).须遵守内存管理的方法命名规则</h5><ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
<li><p>init（ARC有效时，更严格，改方法必须是实例方法，并且必须要返回对象，返回的对象应为id类型或该方法声明类的对象类型，抑或是该类的超类或子类型）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">虽然以init开始的方法但并不包含在上述命名规则里</div><div class="line">- (void) initialize;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="4-不要显示调用dealloc"><a href="#4-不要显示调用dealloc" class="headerlink" title="4).不要显示调用dealloc"></a>4).不要显示调用dealloc</h5><p>deallo方法在大多数情况下适用于删除已注册的代理或观察者对象</p>
<h5 id="5-使用-autoreleasepool块替代NSAutoreleasePool"><a href="#5-使用-autoreleasepool块替代NSAutoreleasePool" class="headerlink" title="5).使用@autoreleasepool块替代NSAutoreleasePool"></a>5).使用@autoreleasepool块替代NSAutoreleasePool</h5><h5 id="6-不能使用区域（NSZone"><a href="#6-不能使用区域（NSZone" class="headerlink" title="6).不能使用区域（NSZone)"></a>6).不能使用区域（NSZone)</h5><p>区域在现在的运行时系统已经单纯地被忽略</p>
<h5 id="7-对象型变量不能作为C语言结构体（struct-union-的成员"><a href="#7-对象型变量不能作为C语言结构体（struct-union-的成员" class="headerlink" title="7).对象型变量不能作为C语言结构体（struct/union)的成员"></a>7).对象型变量不能作为C语言结构体（struct/union)的成员</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct data&#123;</div><div class="line">   NSMutableArray *array;</div><div class="line">&#125;;</div><div class="line">error: ARC forbids Objective-C objs in structs or unions</div><div class="line">NSMutableArray *array;</div></pre></td></tr></table></figure>
<p>要把对象型变量加入到机构提成员中时，可强制转换为 void * 或是附加 __unsafe _unretained 修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct Data&#123;</div><div class="line">      NSMutableArray __unsafe_unretained *array;</div><div class="line">&#125;;</div><div class="line">附有 __unsafe_unretained 修饰符的变量不属于编译器的内存管理对象</div></pre></td></tr></table></figure>
<h5 id="8-显示转换“id”和“void-”"><a href="#8-显示转换“id”和“void-”" class="headerlink" title="8).显示转换“id”和“void * ”"></a>8).显示转换“id”和“void * ”</h5><p>  <strong>__bridge 转换</strong></p>
<ul>
<li>安全性与赋值低，容易因为悬垂指针而导致程序奔溃   </li>
<li>还有<strong>bridge_retained 与 </strong>bridge_transfer两种转换</li>
<li>在Objective-C对象与Core Foundation 对象之间相互变换</li>
</ul>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><table>
<thead>
<tr>
<th>属性声明的属性</th>
<th>所有权修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>__unsafe  _unretained 修饰符</td>
</tr>
<tr>
<td>copy（不是简单的赋值，它赋值的是通过NSCopying接口的copyWithZone:方法赋值源所生成的对象</td>
<td>__strong 修饰符 (赋值的十倍复制的对象）</td>
</tr>
<tr>
<td>retain</td>
<td>__strong 修饰符</td>
</tr>
<tr>
<td>strong</td>
<td>__strong 修饰符</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>__unsafe _unretained</td>
</tr>
<tr>
<td>weak</td>
<td>__weak 修饰符</td>
</tr>
</tbody>
</table>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>在分配内存时推荐使用calloc函数</p>
<h5 id="C-ARC的实现"><a href="#C-ARC的实现" class="headerlink" title="C. ARC的实现"></a>C. ARC的实现</h5><p>ARC由以下工具、库来说实现</p>
<ul>
<li>clang (LLVM编译器）3.0以上</li>
<li>objc4 Objective-C 运行时库 493.9以上</li>
</ul>
<p><strong>__strong修饰符</strong></p>
<table>
<thead>
<tr>
<th>objc_retainAutoreleasedReturnValue</th>
<th>objc_autoreleaseReturnValue</th>
</tr>
</thead>
<tbody>
<tr>
<td>之外类方法等返回对象的实现上</td>
<td>alloc/new/copy/mutableCopy</td>
</tr>
</tbody>
</table>
<p><strong>__weak修饰符</strong> [重点]</p>
<ul>
<li>若附有__weak 修饰符的变量所引用的对象被废弃，则将nil赋值给该变量</li>
<li><p>使用附有__weak 修饰符的变量，即是使用注册到autoreleasepool中的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  id __weak obj1 = obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 编译器模拟代码*/</div><div class="line">id obj1;</div><div class="line">objc_initWeak(&amp;obj1,obj);</div><div class="line">objc_destoryWeak(&amp;obj1);</div><div class="line">*******</div><div class="line">obj1 = 0;</div><div class="line">objc_storeWeak(&amp;obj1,obj);</div><div class="line">*******</div></pre></td></tr></table></figure>
<p><strong>objc_storeWeak 函数把第二参数的赋值对象的地址作为键值，将第一参数的附有__weak修饰符的变量的地址注册到weak表中。如果第二参数为 0，则把变量的地址从weak表中删除。weak表与引用计数表相同，作为散列表被实现。</strong></p>
<p>释放对象，程序的动作：</p>
<ul>
<li>objc_release</li>
<li>引用计数为0，执行dealloc</li>
<li>_ objc _rootDealloc</li>
<li>object_dispose</li>
<li>objc_destructInstance</li>
<li>objc_clear_deallocating</li>
</ul>
</li>
</ul>
<blockquote>
<p> objc _clear _deallocating的函数动作</p>
<ul>
<li>从weak表中获取废弃对象的地址为键值的记录</li>
<li>将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil</li>
<li>从weak表中删除该记录</li>
<li>从引用计数表中删除废弃对象的地址为键值的记录</li>
</ul>
</blockquote>
<p>只在需要避免循环引用时使用__weak修饰符，否则会消耗相应的CPU资源</p>
<p><strong>__autoreleasing修饰符</strong></p>
<p><strong>引用计数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   id __strong obj = [[NSObject alloc] init];</div><div class="line">   NSLog(@&quot;retain count = %d&quot;,_objc_rootRetainCount(obj));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上并不能够完全信任_objc_rootRetainCount函数取得的数值。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/30/多线程与内存管理读书笔记/" class="archive-article-date">
  	<time datetime="2017-03-30T08:37:56.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-30</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-手把手教你封装一个面向对象的数据库-FMDB" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/24/手把手教你封装一个面向对象的数据库-FMDB/">手把手教你封装一个面向对象的数据库(FMDB)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###1.GCD 信号量控制并发 (dispatch_semaphore)</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/24/手把手教你封装一个面向对象的数据库-FMDB/" class="archive-article-date">
  	<time datetime="2017-03-24T07:28:19.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-24</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 菠了个菜
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/c6ad3f2ed2d6/latest_articles">简书</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">仗剑踏风上重楼</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>